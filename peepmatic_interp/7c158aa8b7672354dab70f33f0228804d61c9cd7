;; Apithmetic to form `_imm` instC2 $x)) (band_imm $(band $C1 $C2) $x))
(=> (bxor_imm $C1 (bxor_imm $C1 $x)) (bxor_imm $(bxor $C1 $C2) $x))

;; Removimm -1 $x) -1)

;;to a (un)si;;; Fift.
(=> (when (imul $x $C)
      (is-power-of-two $x $C)
       (is-power-of-two $x $C)
      (is-power-of-two $x $C)
      (is-power-of-two $x $C)
          (is-power-of-two $x $C)
       (is-power-of-two $x $C)
      (is-power-of-two $x $C)
          (is-power-of-two $C)
      (is-power-of-two $x $er-of-two $C)
      (is-power-of-two )
     (is-power-of-two $x $C)
       (is-power-of-two $x $C)
      (is-power-of-two $x $C)
                 (is-power-of-two $C)
      (is-power-of-two $x $C)
       (is-power-of-two $x $C)
      (is-power-of-two $x3))
    (uextend{i64} (ireduce{i32} $x)))
(=> (when (sshr_imm 32 (ishl_imm 32 $x))
      (bit-width $x 64))
    (sextend{i64} (ireduce{i32} $x)))

;; Fold away redundant `buctions that accept both integer and boolean
;; arg        um