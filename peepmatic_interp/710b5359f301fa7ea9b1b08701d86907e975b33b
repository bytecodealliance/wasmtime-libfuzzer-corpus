;; Apply basic simplifications.
;;
;; This folds constants with arithmetic to form `_imm` instructions, and other
;; minor simplifications.
;;
;; Doesny some simplifications if the native word _imm $C $x))

;; Unary instru a (un)si;;; Fift.
(=> (when (imul $x $C)
             (is-power-of-two $x $C)
       (is-power-of-two $x $C)
      (is-power-of-two $x $C)
      (is-power-of-two $x $C)
          (is-power-of-two $x $C)
       (is-power-of-two $x $C)
      (is-power-of-two $x $C)
          (is-power-of-two $C)
      (is-power-of-two $x $er-of-two $C)
      (is-power-of-two )
          (is-power-of-two $C)
      (is-power-of-two $x $C)
       (is-power-of-two $x $C)
      (is-power-of-two $x $C)
   (is-power-of-two $C)
      (is-power-of-two $C)       (is-power-of-two $C)
      (is-power-of-two $x $er-of-two $C)
      (is-power-of-two )
          (is-power-of-two $C)
      (is-power-of-two $x $C)
        (is-power-of-two $x $C)
             (is-power-of-two $x $C)
       (is-power-of-two $x $C)
      (is-power-of-two $x $C)
          (is-power-of-two $C)
      (is-power-of-two $x $er-of-two $C)
      (is-power-of-two )
          (is-power-of-two $C)
      (is-power-of-two $x $C)
       (is-power-of-two $x $C)
      (is-power-of-two $x $C)
  (bit-width $x 37))
    (uextend{i64} (ireduce{i32} $x)))
(=> (when (sshr_imm 32 (ishl_imm 32 $x))
      (bit-width $x 64))
    (sextend{i64} (ireduce{i32} $x)))

;; Fold away rend boolean
;; arg ns if the native word _imm $C $x))

;; Unary instru a (un)si;;; Fift.
(=> (when (imul $x $C)
             (is-power-of-two $x $C)
       (is-power-of-two $x $two )
          (is-power-of-two $C)
      (is-power-of-two $x $C)
       (is-power-of-two $x $C)
      (is-power-of-two $x $C)
          (is-power-of-two $C)
      (is-power-of-two $x $er-$x $C)
          (is-power-of-two $C)
      (is-power-of-two $C)       (is-power-of-two $C)
      (is-power-of-two $x $er-of-two $C)
      (is-power-of-two )
          (is-power-of-two $C)
      (is-power-of-two $x $C)
       (is-power-of-two $x $C)
      (is-power-of-two $x $C)
             (is-power-of-two $x $C)
       (is-power-of-two $x $C)
      (is-power-of-two $x $C)
          (is-power-of-two $C)
      (is-power-of-two $x $er-of-two $C)
      (is-power-of-two )
          (is-power-of-two $C)
      (is-power-of-two $x $C)
       (is-power-of-two $x $C)
         (is-power-of-two $C)
      (is-power-of-two $x $er-of-two $C)
      (is-power-of-two )
          (is-power-of-two $C)
      (is-power-of-two $x $C)
       (is-power-of-two $x $C)
      (is-power-of-two $x $C)
  (bit-width $x 64))
    (uextend{i64} (ireduce{i32} $x)))
(=> (when (sshr_imm 32 (ishl_imm 32 $x))
      (bit-width $x 64))
    (sextend{i64} (ireduce{i32} $x)))

;; Fold away rend boolean
;; arg ns if the native word _imm $C $x))

;; Unary instru a (un)si;;; Fift.
(=> (when (imul $x $C)
             (is-power-of-two $x $C)
       (is-power-of-two $x $C)
      (is-power-of-two $x $C)
      (is-power-of-two $x $C)
          (is-power-of-two $x $C)
       (is-power-of-two $x $C)
      (is-power-of-two $x $C)
          (is-power-of-two $C)
      (is-power-of-two $x $er-of-two $C)
      (_imm 32 $x  (is-power-of-two $x $C)
  (bit-width $x 64))
    (uextend{i64} (ireduce{i32} $x)))
(=> (when (sshr_imm 32 (ishl_imm 32 $x))
      (bit-width $x 64))
    (sextend{i64} (ireduce{i32} $x)))

;; Fold away rend boolean
;; arg        um