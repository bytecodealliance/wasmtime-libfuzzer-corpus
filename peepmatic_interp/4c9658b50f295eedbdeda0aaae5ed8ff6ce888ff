(=> 4 0)(=> 8 0);; Apply basic simplifications.
;;
;; Thi; folds constants with arithmetic to form `_imm` instinor simplifications.
;;
;; Doesn't apply somehe nf the instruction. This would
;; mm $C $x))
(=> (when (udiv $x $C)
      (fits-in-native-word $C))
    (udiv_imm $C $x))
(=> (when (srem $x $C)
      (fits-in-native-word $C))
    (srem_imm $C $x))
(=> (when (urem $x $C)
      (fits-in-native-word $C))
    (urem_imm $C $x))
(=> (when (band $x $C)
      (fits-in-native-word $C))
    (band_imm $C $x))
(=> (when (bor $x $C)
      (fits-in-native-word $C))
    (bor_imm $C $x))
(=> (when (bxor $x $C)
      (fits-in-native-word $C))
    (bxor_imm $C $x))
(=> (when (rotl $x $C)
      (fits-in-native-word $C))
    (rotl_imm $C $x))
(=> (when (rotr $x $C)
      (fits-in-native-word $C))
    (rotr_imm $C $x))
(=> (when (ishl $x $C)
      (fits-in-native-word $C))
    (ishl_imm $C $x))
(=> (when (ushr $x $C)
      (fits-in-native-word $C))
    (ushr_imm $C $x))
(=> (when (sshr $x $C)
      (fits-in-native-word $C))
    (sshr_imm $C $x))
(=> (when (isub $x $C)
      (fits-in-native-word $C))
    (iadd_imm $(neg $C) $x))
(=> (when (ifcmp $cond $x $C)
      (fits-in-native-word $C))
    (ifcmp_imm $cond $C $x))
(=> (when (icmp $cond $x $C)
      (fits-in-native-word $C))
    (icmp_imm $cond $C $x))

;; Bi $x))
(=> (when (band $C $x)
      (fits-in-native-word $C))
    (band_imm $C $x))
(=> (when (bor $C $x)
      (fits-in-native-word $C))
    (bor_imm $C $x))
(=> (when (bxor $C $x)
      (fits-in-native-word $C))
    (bxor_imm $C $x))
(=> (when (isub $C $x)
      (fits-in-native-word $C))
    (irsub_imm $C $x))

;;ary instructions whose operand is constant.
(=> (adjust_sp_down $C) (adjust_sp_down_imm $C))

;; Fold `(binop_iivrem_transformation
